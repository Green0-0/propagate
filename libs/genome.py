import json
import math
from typing import List, Tuple
from random import randint

import torch

class Genome:
    seeds: List[int]
    perturb_scales: List[float]
    historical_rewards: List[float]
    
    latest_inputs: List[str]
    latest_outputs: List[str]
    latest_rewards: List[float]
    
    starting_index = 0

    def __init__(self):
        """Initialize the Genome.
        Note: The length of the seeds, perturb_scales, and historical_rewards (this is the mean reward attained at a generation) lists should be the same after reward calculation. The seeds and perturb_scales should have one greater length when a new seed is added, which is then corrected when rewards are calculated. 
        New meaningful seeds are added at and past the starting_index, before that point are seeds generated by previous backprop steps with sentinel valued rewards.
        Additionally, all genomes of a generation should have the same length of seeds, perturb_scales, and historical_rewards, and the value of starting_index should be the same.
        
        Attributes
        ----------
        seeds : List[int]
            A list of integer seeds representing the genome's parameters. 
        perturb_scales : List[float]
            A list of weights corresponding to each seed. The weight of the seed should always be sigma unless it has been absorbed into a backprop step.
        historical_rewards : List[float]
            A list of historical rewards received by the genome.
        latest_outputs : List[str]
            A list of the latest outputs of the genome.
        latest_rewards : List[float]
            A list of the latest rewards received by the genome.
        starting_index : int
            The index in which new seeds of this generation are being generated. Seeds before this index were in a previous backprop step and should not be touched.
        """
        self.seeds = []
        self.perturb_scales = []
        self.historical_rewards = []
        
        self.latest_prompts = []
        self.latest_outputs = []
        self.latest_rewards = []
        self.starting_index = 0

    def cross(self, other: 'Genome', existing_seeds: List[int], perturb_scale: float) -> Tuple['Genome', int]:
        """Perform crossover between this genome and another genome (possibly the same genome) to produce a child genome. 
        This crossover step must produce a unique new genome with i+1 seeds. If no unique seed can be found, a mutation is performed.

        Args:
            other (Genome): The other genome to crossover with. If None or the same as self, a mutation is performed instead.
            existing_seeds (List[int]): A list of existing seeds already produced by the parent in other children to avoid duplicates.
            perturb_scale (float): The weight to assign to the new seed. This corresponds with the hyperparameter sigma.
            
        Returns:
            Tuple[Genome, int]: A tuple containing the child genome and the newly added seed.
        """
        # Sanity check
        assert len(self.seeds) == len(self.perturb_scales) 
        assert len(self.seeds) == len(self.historical_rewards)
        assert len(other.seeds) == len(self.seeds)
        assert self.starting_index == other.starting_index
        
        child = Genome()
        child.seeds = self.seeds.copy()
        child.perturb_scales = self.perturb_scales.copy()
        child.historical_rewards = self.historical_rewards.copy()
        child.starting_index = self.starting_index
        if other is None or other is self:
            return child, child.mutate_seed(perturb_scale)
        
        novel_seeds = []
        for i in range(other.starting_index, len(other.seeds)):
            s = other.seeds[i]
            if s not in self.seeds and s not in existing_seeds:
                novel_seeds.append(s)
        if not novel_seeds:
            return child, child.mutate_seed(perturb_scale)

        index = randint(0, len(novel_seeds) - 1)
        selected_seed = novel_seeds[index]
        original_index_in_other = other.seeds.index(selected_seed)
        
        child.seeds.append(selected_seed)
        child.perturb_scales.append(other.perturb_scales[original_index_in_other])
        return child, selected_seed

    def mutate_seed(self, perturb_scale: float) -> int:
        """Mutate the genome by adding a new unique seed.

        Args:
            perturb_scale (float): The weight to assign to the new seed. This corresponds with the hyperparameter sigma.

        Returns:
            int: The newly added seed.
        """
        new_seed = randint(0, 1000000)
        while new_seed in self.seeds:
            new_seed = randint(0, 1000000)
        self.seeds.append(new_seed)
        self.perturb_scales.append(perturb_scale)
        return new_seed
    
    def get_copy(self) -> 'Genome':
        """Get a copy of this genome.

        Returns:
            Genome: The copied genome.
        """
        copy = Genome()
        copy.seeds = self.seeds.copy()
        copy.perturb_scales = self.perturb_scales.copy()
        copy.historical_rewards = self.historical_rewards.copy()
        copy.starting_index = self.starting_index
        return copy
    
    def get_mirrored(self) -> 'Genome':
        """Get a mirrored version of this genome, where the latest seed is negated.

        Returns:
            Genome: The mirrored genome.
        """
        if self.seeds == []:
            raise ValueError("Cannot mirror a genome with no seeds.")
        mirrored = Genome()
        mirrored.seeds = self.seeds.copy()
        mirrored.perturb_scales = self.perturb_scales.copy()
        mirrored.historical_rewards = self.historical_rewards.copy()
        mirrored.starting_index = self.starting_index
        mirrored.perturb_scales[-1] = -mirrored.perturb_scales[-1]
        return mirrored
    
def difference_rewards(A: Genome, B: Genome) -> float:
    """Calculate the difference in rewards attained on the outputs within the latest generation between two genomes.

    Args:
        A (Genome): The first genome to compare.
        B (Genome): The second genome to compare.

    Returns:
        float: the normalized difference in rewards between the two genomes
    """

    total = sum(A.latest_rewards) + sum(B.latest_rewards)
    difference = sum(abs(a - b) for a, b in zip(A.latest_rewards, B.latest_rewards))
    return (difference / total) if total > 0 else 0

def difference_seeds(A: Genome, B: Genome) -> float:
    """Calculate the difference in seeds between two genomes. This is simply the percentage of disjoint seeds.

    Args:
        A (Genome): The first genome to compare.
        B (Genome): The second genome to compare.

    Returns:
        float: the normalized difference in seeds between the two genomes
    """
    total = len(A.seeds) + len(B.seeds)
    disjoints = set(A.seeds).symmetric_difference(set(B.seeds))
    difference = len(disjoints)
    return (difference / total) if total > 0 else 0