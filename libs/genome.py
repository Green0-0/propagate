from typing import List, Tuple
from random import randint

class Genome:
    seeds: List[int]
    seed_weights: List[float]
    historical_rewards: List[float]
    
    latest_outputs: List[str]
    latest_rewards: List[float]
    
    starting_index = 0

    def __init__(self):
        """Initialize the Genome.
        Note: The length of the seeds, seed_weights, and historical_rewards (this is the mean reward attained at a generation) lists should be the same after reward calculation. The seeds and seed_weights should have one greater length when a new seed is added, which is then corrected when rewards are calculated. 
        New meaningful seeds are added at and past the starting_index, before that point are seeds generated by previous backprop steps with sentinel valued rewards.
        Additionally, all genomes of a generation should have the same length of seeds, seed_weights, and historical_rewards, and the value of starting_index should be the same.
        
        Attributes
        ----------
        seeds : List[int]
            A list of integer seeds representing the genome's parameters. 
        seed_weights : List[float]
            A list of weights corresponding to each seed. The weight of the seed should always be sigma unless it has been absorbed into a backprop step.
        historical_rewards : List[float]
            A list of historical rewards received by the genome.
        latest_outputs : List[str]
            A list of the latest outputs of the genome.
        latest_rewards : List[float]
            A list of the latest rewards received by the genome.
        starting_index : int
            The index in which new seeds of this generation are being generated. Seeds before this index were in a previous backprop step and should not be touched.
        """
        self.seeds = []
        self.seed_weights = []
        self.historical_rewards = []
        self.latest_outputs = []
        self.latest_rewards = []
        self.starting_index = 0

    def cross(self, other: 'Genome', existing_seeds: List[int], weight: float) -> Tuple['Genome', int]:
        """Perform crossover between this genome and another genome (possibly the same genome) to produce a child genome. 
        This crossover step must produce a unique new genome with i+1 seeds. If no unique seed can be found, a mutation is performed.

        Args:
            other (Genome): The other genome to crossover with. If None or the same as self, a mutation is performed instead.
            existing_seeds (List[int]): A list of existing seeds already produced by the parent in other children to avoid duplicates.
            weight (float): The weight to assign to the new seed. This corresponds with the hyperparameter sigma.
            
        Returns:
            Tuple[Genome, int]: A tuple containing the child genome and the newly added seed.
        """
        # Sanity check
        assert len(self.seeds) == len(self.seed_weights) 
        assert len(self.seeds) == len(self.historical_rewards)
        assert len(other.seeds) == len(self.seeds)
        assert self.starting_index == other.starting_index
        
        child = Genome()
        child.seeds = self.seeds.copy()
        child.seed_weights = self.seed_weights.copy()
        child.historical_rewards = self.historical_rewards.copy()
        child.starting_index = self.starting_index
        if other is None or other is self:
            return child, child._mutate_seed(weight)
        
        novel_seeds = []
        for i in range(other.starting_index, len(other.seeds)):
            s = other.seeds[i]
            if s not in self.seeds and s not in existing_seeds:
                novel_seeds.append(s)
        if not novel_seeds:
            return child, child._mutate_seed(weight)

        index = randint(0, len(novel_seeds) - 1)
        selected_seed = novel_seeds[index]
        original_index_in_other = other.seeds.index(selected_seed)
        
        child.seeds.append(selected_seed)
        child.seed_weights.append(other.seed_weights[original_index_in_other])
        return child, selected_seed

    def _mutate_seed(self, weight: float) -> int:
        """Mutate the genome by adding a new unique seed.

        Args:
            weight (float): The weight to assign to the new seed. This corresponds with the hyperparameter sigma.

        Returns:
            int: The newly added seed.
        """
        new_seed = randint(0, 2**32 - 1)
        while new_seed in self.seeds:
            new_seed = randint(0, 2**32 - 1)
        self.seeds.append(new_seed)
        self.seed_weights.append(weight)
        return new_seed
    
    def apply_to_tensor(self, named_tensor):
        pass
    
    def revert_from_tensor(self, named_tensor):
        pass
    
def difference_rewards(A: Genome, B: Genome) -> float:
    """Calculate the difference in rewards attained on the outputs within the latest generation between two genomes.

    Args:
        A (Genome): The first genome to compare.
        B (Genome): The second genome to compare.

    Returns:
        float: the normalized difference in rewards between the two genomes
    """

    total = sum(A.latest_rewards) + sum(B.latest_rewards)
    difference = sum(abs(a - b) for a, b in zip(A.latest_rewards, B.latest_rewards))
    return (difference / total) if total > 0 else 0

def difference_seeds(A: Genome, B: Genome) -> float:
    """Calculate the difference in seeds between two genomes. This is simply the percentage of disjoint seeds.

    Args:
        A (Genome): The first genome to compare.
        B (Genome): The second genome to compare.

    Returns:
        float: the normalized difference in seeds between the two genomes
    """
    total = len(A.seeds) + len(B.seeds)
    disjoints = set(A.seeds).symmetric_difference(set(B.seeds))
    difference = len(disjoints)
    return (difference / total) if total > 0 else 0

def merge_genomes(genomes: List[Genome], learning_rate: float) -> Genome:
    """Perform a single gradient step on a list of genomes based on their rewards r, seeds s, and learning rate a.
    The update rule for the new seeds follows the paper source [1/N * a * sum_j ((r_j - mean(r)) / stddev(r) * noise)]
    Since genomes may have taken different gradient steps in the past, the update rule for the previous gradients is simply an averaged merge.
    The weights of these updates are summed together to form the weights of the new seeds. 
    
    Args:
        genomes (List[Genome]): The list of genomes to merge.
        learning_rate (float): The learning rate to use for the gradient step.

    Returns:
        Genome: The merged genome.
    """
    merged = Genome()
    reward_mean = sum([g.historical_rewards[-1] for g in genomes]) / len(genomes)
    reward_stddev = (sum([(g.historical_rewards[-1] - reward_mean) ** 2 for g in genomes]) / len(genomes)) ** 0.5
    new_seeds = {}
    for g in genomes:
        for i in range(len(g.seeds)):
            # If this is a new seed, apply the gradient step update. If this is an old seed (generated by a gradient step), retain its previous weight.
            seed = g.seeds[i]
            weight = g.seed_weights[i]
            if seed not in new_seeds:
                if i < g.starting_index:
                    new_seeds[seed] = weight/len(genomes)
                else:
                    new_seeds[seed] = (1/len(genomes)) * learning_rate * (g.historical_rewards[-1] - reward_mean) / (reward_stddev + 1e-8)
            else:
                if i < g.starting_index:
                    new_seeds[seed] += weight/len(genomes)
                else:
                    new_seeds[seed] += (1/len(genomes)) * learning_rate * (g.historical_rewards[-1] - reward_mean) / (reward_stddev + 1e-8)
    for seed, weight in new_seeds.items():
        merged.seeds.append(seed)
        merged.seed_weights.append(weight)
        merged.historical_rewards.append(float('-inf'))  # placeholder sentinel value -inf
    merged.starting_index = len(merged.seeds)
    return merged