from typing import List
from random import randint

class Genome:
    """The genome represents a singular, unique model. Evaluation is performed on the genome by applying its seeds and perturb scales to the model. The genome also serves as a container that stores evaluation statistics for gradient approximation.

    Note: The length of the seeds, perturb_scales, and historical_rewards (this is the mean reward attained at a generation) lists should be the same after reward calculation. The seeds and perturb_scales should have one greater length when a new seed is added, which is then corrected when rewards are calculated. 

    New meaningful seeds are added at and past the starting_index, before that point are seeds generated by previous backprop steps with sentinel valued rewards.

    Additionally, all genomes of a generation should have the same length of seeds, perturb_scales, and historical_rewards, and the value of starting_index should be the same. This means that all genomes derive from the same parent, which keeps reward calculations consistent.
    
    Attributes
    ----------
    seeds : List[int]
        A list of integer seeds representing the genome's parameters. 
    perturb_scales : List[float]
        A list of weights corresponding to each seed. The weight of the seed should always be equal to the perturb weight unless it has been absorbed into a backprop step or is being mirrored.
    historical_rewards : List[float]
        A list of historical rewards received by the genome.
    latest_outputs : List[str]
        A list of the latest outputs of the genome.
    latest_rewards : List[float]
        A list of the latest rewards received by the genome.
    starting_index : int
        The index in which new seeds of this generation are being generated. Seeds before this index were in a previous backprop step and should not be touched.
    """
    seeds: List[int]
    perturb_scales: List[float]
    historical_rewards: List[float]
    
    latest_inputs: List[str]
    latest_outputs: List[str]
    latest_rewards: List[float]
    
    starting_index = 0

    def __init__(self):
        self.seeds = []
        self.perturb_scales = []
        self.historical_rewards = []
        
        self.latest_inputs = []
        self.latest_outputs = []
        self.latest_rewards = []
        self.starting_index = 0

    def mutate_seed(self, perturb_scale: float) -> int:
        """Mutate the genome by adding a new unique seed.

        Args:
            perturb_scale (float): The weight to assign to the new seed. This corresponds with the hyperparameter sigma.

        Returns:
            int: The newly added seed.
        """
        new_seed = randint(0, 1000000)
        while new_seed in self.seeds:
            new_seed = randint(0, 1000000)
        self.seeds.append(new_seed)
        self.perturb_scales.append(perturb_scale)

        self.latest_inputs = []
        self.latest_outputs = []
        self.latest_rewards = []
        return new_seed
    
    def get_copy(self) -> 'Genome':
        """Get a copy of this genome.

        Returns:
            Genome: The copied genome.
        """
        copy = Genome()
        copy.seeds = self.seeds.copy()
        copy.perturb_scales = self.perturb_scales.copy()
        copy.historical_rewards = self.historical_rewards.copy()
        copy.starting_index = self.starting_index
        return copy
    
    def get_mirrored(self) -> 'Genome':
        """Get a mirrored version of this genome, where the latest seed is negated.

        Returns:
            Genome: The mirrored genome.
        """
        if self.seeds == []:
            raise ValueError("Cannot mirror a genome with no seeds.")
        mirrored = self.get_copy()
        mirrored.perturb_scales[-1] = -mirrored.perturb_scales[-1]
        return mirrored